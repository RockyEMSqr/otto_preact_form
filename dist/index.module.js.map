{"version":3,"file":"index.module.js","sources":["../src/form/text.tsx","../src/form/input.tsx","../src/utils.ts"],"sourcesContent":["import { Input, InputNameCheckProps } from \"./input\";\nimport { h } from 'preact';\nexport class Text<T> extends Input<InputNameCheckProps<T>> {\n    type = \"text\";\n    render(props?: any, state?: any) {\n        return super.render(props, state)\n    }\n}","import { render, Component, h } from 'preact';\nimport linkState from 'linkstate';\n\n\nimport { JSXInternal as JSX } from 'preact/src/jsx';\nimport { delve } from '../utils';\n\nexport type Item = { name: any, value: any };\n\ntype Decr = [never, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n\n// type NestedKeyOf<ObjectType extends object, N extends number = 4> =\n//     { [Key in keyof ObjectType & (string | number)]: ObjectType[Key] extends object\n//         ? `${Key}` | `${Key}.${NestedKeyOf<ObjectType[Key], Decr[N]>}`\n//         : `${Key}`\n//     }[keyof ObjectType & (string | number)];\n\ntype NotRecursiveKeyOf<ObjectType extends object> =\n    { [Key in keyof ObjectType & (string | number)]:\n        ObjectType[Key] extends object\n        ? `${Key}` | { [Key1 in keyof ObjectType[Key] & (string | number)]:\n            ObjectType[Key][Key1] extends object\n            ? `${Key}.${Key1}` | {\n                [Key2 in keyof ObjectType[Key][Key1] & (string | number)]:\n                ObjectType[Key][Key1][Key2] extends object\n                ? `${Key}.${Key1}.${Key2}` | {\n                    [Key3 in keyof ObjectType[Key][Key1][Key2] & (string | number)]:\n                    ObjectType[Key][Key1][Key2] extends object\n                    ? `${Key}.${Key1}.${Key2}.${Key3}` | 'Max Hit. Tell Rocky if you need more'\n                    : `${Key}.${Key1}.${Key2}.${Key3}`\n                }[keyof ObjectType[Key][Key1][Key2] & (string | number)]\n                : `${Key}.${Key1}.${Key2}`\n            }[keyof ObjectType[Key][Key1] & (string | number)]\n            : `${Key}.${Key1}`\n        }[keyof ObjectType[Key] & (string | number)]\n        : `${Key}`\n    }[keyof ObjectType & (string | number)];\n\ntype Join<K, P> = K extends string | number ?\n    P extends string | number ?\n    `${K}${\"\" extends P ? \"\" : \".\"}${P}`\n    : never : never;\ntype Prev = [never, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n    11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...0[]]\ntype Paths<T, D extends number = 10> = [D] extends [never] ? never :\n    T extends void ? 'Boo' :\n    T extends never ? 'Boo' :\n    T extends object ?\n    { [K in keyof T]-?: K extends string | number ?\n        `${K}` | Join<K, Paths<T[K], Prev[D]>>\n        : never\n    }[keyof T] : \"\"\n\ntype Leaves<T = void, D extends number = 5> = [D] extends [never] ? never :\n    T extends object ?\n    { [K in keyof T]-?: Join<K, Leaves<T[K], Prev[D]>> }[keyof T] : string;\nexport type InputNameCheckProps<T = void> = {\n    name?: T extends void ? string :\n    T extends Object ? NotRecursiveKeyOf<T> : string;//Paths<T>\n}\nexport type InputProps = { linkTo?: { state: any, setState: any }, inputClass?: string, onChange?: (e: any, o1?: any) => void, onClick?: (e: any, o1?: any) => void, onInput?: (e: any) => void, label?: string | JSX.Element };\nexport type AllInputProps<P> = P & InputProps\n    & Pick<JSX.HTMLAttributes, Exclude<keyof JSX.HTMLAttributes, keyof InputProps>>;\nexport type InputState = { value?: any }\nexport abstract class Input<P = {}, S = {}> extends Component<\n    AllInputProps<P>, S & InputState>{\n    abstract type: string;\n    prepend: undefined | string | JSX.Element;\n    append: undefined | string | JSX.Element;\n    inp: HTMLInputElement | HTMLSelectElement | undefined | null;\n    getValue() {\n        if (this.state.value) {\n            return this.state.value;\n        }\n        if (this.props['value'] != undefined) {\n            return this.props['value'];\n        }\n        if (this.props.linkTo) {\n            let dval = delve(this.props.linkTo.state, this.props.name as string);\n            return dval;\n        }\n\n        if (this.inp) {\n            return this.inp.value;\n        }\n        return null;\n    }\n    getOnChange() {\n        // if (!this.props.name) {\n        //     throw Error('No Name');\n        // }\n        if (this.props.linkTo) {\n            let ls = linkState(this.props.linkTo, this.props.name as string);\n            if (this.props.onChange) {\n                return (e: any) => {\n                    ls(e);\n                    this.props.onChange && this.props.onChange(e);\n                }\n            }\n            return ls;\n\n\n        } else {\n            return this.props.onChange;\n        }\n    }\n    getOnInput() {\n        if (this.props.onInput) {\n            if (this.props.linkTo) {\n                let ls = linkState(this.props.linkTo, this.props.name as string);\n                return (e: any) => {\n                    ls(e);\n                    e.value = this.getValue();\n                    this.props.onInput && this.props.onInput(e);\n                }\n            }\n        }\n        return undefined;\n    }\n\n    public get label() {\n        return this.props.label;\n    }\n    public get isRequired() {\n        return this.props.required;\n    }\n    public get inputClass() {\n        return `form-control ${this.props.inputClass || null} ${this.isRequired ? 'required' : ''}`;\n    }\n    public get labelClass() {\n        return this.isRequired ? 'required' : '';\n    }\n    public get id() {\n        return this.props.id || this.props.name;\n    }\n    render(props?: any, state?: any) {\n        let attributes = { ...props, linkTo: null, label: null }\n        let placeholder = props.placeholder;\n\n        if (!placeholder && typeof props.label == 'string') {\n            placeholder = props.label;\n        }\n        return (\n            <div class=\"form-group\">\n                {this.label && <label for={this.id} class={this.labelClass}>{this.label}</label>}\n                <div class=\"input-group\">\n                    {this.prepend}\n                    <input {...attributes} ref={x => this.inp = x} onChange={this.getOnChange()} onInput={this.getOnInput()} value={this.getValue()} type={this.type} class={this.inputClass} name={props?.name} id={this.id} placeholder={placeholder} />\n                    {this.append}\n                </div>\n            </div>\n        );\n    }\n\n}","export function dset(obj: any, keys: string | any, val: any) {\n    keys.split && (keys = keys.split('.'));\n    var i = 0, l = keys.length, t = obj, x;\n    for (; i < l; ++i) {\n        x = t[keys[i]];\n        t = t[keys[i]] = (i === l - 1 ? val : (x != null ? x : (!!~keys[i + 1].indexOf('.') || !(+keys[i + 1] > -1)) ? {} : []));\n    }\n}\nexport function addBlankDefaultToItems(items: any[], defaultText?: string) {\n    return [{ name: defaultText, value: '' }].concat(items);\n}\n/**\n * todo(rc): needs to be better\n */\nexport function formatPhoneNumber(s: string) {\n    console.info('handle formatting better.')\n    var s2 = (\"\" + s).replace(/\\D/g, '');\n    var m = s2.match(/^(\\d{3})(\\d{3})(\\d{4})$/);\n    return (!m) ? null : \"(\" + m[1] + \") \" + m[2] + \"-\" + m[3];\n}\nimport dlv from 'dlv';\nexport function delve(object: object, key: string | Array<string | number>, defaultValue?: any) {\n    return dlv(object, key, defaultValue);\n}\nexport const dget = dlv;\n/**\n * Debounce a function call. \n * Useful for oninputs so its only called when user stops typing\n * @param delay \n * @param fn \n */\nexport function debounce(delay: number, fn: Function) {\n    let timerId: any;\n    return function (...args: any[]) {\n        if (timerId) {\n            clearTimeout(timerId);\n        }\n        timerId = setTimeout(() => {\n            fn(...args);\n            timerId = null;\n        }, delay);\n    };\n}\n/**\n * debounce with a default 500 ms(for now)\n * @param fn \n */\nexport function debouncex(fn: Function) {\n    return debounce(500, fn);\n}\n"],"names":["Text","type","render","props","state","prepend","append","inp","getValue","this","value","undefined","linkTo","dlv","name","defaultValue","getOnChange","ls","linkState","onChange","e","_this2","getOnInput","onInput","_this3","attributes","label","placeholder","class","h","for","id","labelClass","ref","x","_this4","inputClass","required","isRequired","Component"],"mappings":"+dAEaA,mKACTC,KAAO,mCACPC,OAAA,SAAOC,EAAaC,GAChB,mBAAaF,iBAAOC,EAAOC,wKC+D/BC,iBACAC,gBACAC,mDACAC,SAAA,WACI,OAAIC,KAAKL,MAAMM,WACCN,MAAMM,MAEKC,MAAvBF,KAAKN,MAAL,WACYA,MAAL,MAEPM,KAAKN,MAAMS,OCxDZC,EDyDkBJ,KAAKN,MAAMS,OAAOR,MAAOK,KAAKN,MAAMW,UC1DWC,GD8DhEN,KAAKF,SACOA,IAAIG,cAIxBM,YAAA,sBAII,GAAIP,KAAKN,MAAMS,OAAQ,CACnB,IAAIK,EAAKC,EAAUT,KAAKN,MAAMS,OAAQH,KAAKN,MAAMW,MACjD,OAAIL,KAAKN,MAAMgB,kBACHC,GACJH,EAAGG,GACHC,EAAKlB,MAAMgB,UAAYE,EAAKlB,MAAMgB,SAASC,IAG5CH,EAIP,YAAYd,MAAMgB,YAG1BG,WAAA,sBACI,GAAIb,KAAKN,MAAMoB,SACPd,KAAKN,MAAMS,OAAQ,CACnB,IAAIK,EAAKC,EAAUT,KAAKN,MAAMS,OAAQH,KAAKN,MAAMW,MACjD,gBAAQM,GACJH,EAAGG,GACHA,EAAEV,MAAQc,EAAKhB,WACfgB,EAAKrB,MAAMoB,SAAWC,EAAKrB,MAAMoB,QAAQH,QAsBzDlB,OAAA,SAAOC,EAAaC,cACZqB,OAAkBtB,GAAOS,OAAQ,KAAMc,MAAO,OAC9CC,EAAcxB,EAAMwB,YAKxB,OAHKA,GAAqC,iBAAfxB,EAAMuB,QAC7BC,EAAcxB,EAAMuB,gBAGfE,MAAM,cACNnB,KAAKiB,OAASG,WAAOC,IAAKrB,KAAKsB,GAAIH,MAAOnB,KAAKuB,YAAavB,KAAKiB,OAClEG,SAAKD,MAAM,eACNnB,KAAKJ,QACNwB,eAAWJ,GAAYQ,IAAK,SAAAC,UAAKC,EAAK5B,IAAM2B,GAAGf,SAAUV,KAAKO,cAAeO,QAASd,KAAKa,aAAcZ,MAAOD,KAAKD,WAAYP,KAAMQ,KAAKR,KAAM2B,MAAOnB,KAAK2B,WAAYtB,WAAMX,SAAAA,EAAOW,KAAMiB,GAAItB,KAAKsB,GAAIJ,YAAaA,KACtNlB,KAAKH,mCA5BtB,WACI,YAAYH,MAAMuB,8BAEtB,WACI,YAAYvB,MAAMkC,iCAEtB,WACI,uBAAuB5B,KAAKN,MAAMiC,YAAc,WAAQ3B,KAAK6B,WAAa,WAAa,4BAE3F,WACI,YAAYA,WAAa,WAAa,mBAE1C,WACI,YAAYnC,MAAM4B,IAAMtB,KAAKN,MAAMW,oPArESyB"}