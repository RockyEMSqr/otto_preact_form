{"version":3,"file":"index.umd.js","sources":["../src/form/input.tsx","../src/utils.ts","../src/form/text.tsx"],"sourcesContent":["import { render, Component, h } from 'preact';\nimport linkState from 'linkstate';\n\n\nimport { JSXInternal as JSX } from 'preact/src/jsx';\nimport { delve } from '../utils';\n\nexport type Item = { name: any, value: any };\n\ntype Decr = [never, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n\n// type NestedKeyOf<ObjectType extends object, N extends number = 4> =\n//     { [Key in keyof ObjectType & (string | number)]: ObjectType[Key] extends object\n//         ? `${Key}` | `${Key}.${NestedKeyOf<ObjectType[Key], Decr[N]>}`\n//         : `${Key}`\n//     }[keyof ObjectType & (string | number)];\n\ntype NotRecursiveKeyOf<ObjectType extends object> =\n    { [Key in keyof ObjectType & (string | number)]:\n        ObjectType[Key] extends object\n        ? `${Key}` | { [Key1 in keyof ObjectType[Key] & (string | number)]:\n            ObjectType[Key][Key1] extends object\n            ? `${Key}.${Key1}` | {\n                [Key2 in keyof ObjectType[Key][Key1] & (string | number)]:\n                ObjectType[Key][Key1][Key2] extends object\n                ? `${Key}.${Key1}.${Key2}` | {\n                    [Key3 in keyof ObjectType[Key][Key1][Key2] & (string | number)]:\n                    ObjectType[Key][Key1][Key2] extends object\n                    ? `${Key}.${Key1}.${Key2}.${Key3}` | 'Max Hit. Tell Rocky if you need more'\n                    : `${Key}.${Key1}.${Key2}.${Key3}`\n                }[keyof ObjectType[Key][Key1][Key2] & (string | number)]\n                : `${Key}.${Key1}.${Key2}`\n            }[keyof ObjectType[Key][Key1] & (string | number)]\n            : `${Key}.${Key1}`\n        }[keyof ObjectType[Key] & (string | number)]\n        : `${Key}`\n    }[keyof ObjectType & (string | number)];\n\ntype Join<K, P> = K extends string | number ?\n    P extends string | number ?\n    `${K}${\"\" extends P ? \"\" : \".\"}${P}`\n    : never : never;\ntype Prev = [never, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n    11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...0[]]\ntype Paths<T, D extends number = 10> = [D] extends [never] ? never :\n    T extends void ? 'Boo' :\n    T extends never ? 'Boo' :\n    T extends object ?\n    { [K in keyof T]-?: K extends string | number ?\n        `${K}` | Join<K, Paths<T[K], Prev[D]>>\n        : never\n    }[keyof T] : \"\"\n\ntype Leaves<T = void, D extends number = 5> = [D] extends [never] ? never :\n    T extends object ?\n    { [K in keyof T]-?: Join<K, Leaves<T[K], Prev[D]>> }[keyof T] : string;\nexport type InputNameCheckProps<T = void> = {\n    name?: T extends void ? string :\n    T extends Object ? NotRecursiveKeyOf<T> : string;//Paths<T>\n}\nexport type InputProps = { linkTo?: { state: any, setState: any }, inputClass?: string, onChange?: (e: any, o1?: any) => void, onClick?: (e: any, o1?: any) => void, onInput?: (e: any) => void, label?: string | JSX.Element };\nexport type AllInputProps<P> = P & InputProps\n    & Pick<JSX.HTMLAttributes, Exclude<keyof JSX.HTMLAttributes, keyof InputProps>>;\nexport type InputState = { value?: any }\nexport abstract class Input<P = {}, S = {}> extends Component<\n    AllInputProps<P>, S & InputState>{\n    abstract type: string;\n    prepend: undefined | string | JSX.Element;\n    append: undefined | string | JSX.Element;\n    inp: HTMLInputElement | HTMLSelectElement | undefined | null;\n    getValue() {\n        if (this.state.value) {\n            return this.state.value;\n        }\n        if (this.props['value'] != undefined) {\n            return this.props['value'];\n        }\n        if (this.props.linkTo) {\n            let dval = delve(this.props.linkTo.state, this.props.name as string);\n            return dval;\n        }\n\n        if (this.inp) {\n            return this.inp.value;\n        }\n        return null;\n    }\n    getOnChange() {\n        // if (!this.props.name) {\n        //     throw Error('No Name');\n        // }\n        if (this.props.linkTo) {\n            let ls = linkState(this.props.linkTo, this.props.name as string);\n            if (this.props.onChange) {\n                return (e: any) => {\n                    ls(e);\n                    this.props.onChange && this.props.onChange(e);\n                }\n            }\n            return ls;\n\n\n        } else {\n            return this.props.onChange;\n        }\n    }\n    getOnInput() {\n        if (this.props.onInput) {\n            if (this.props.linkTo) {\n                let ls = linkState(this.props.linkTo, this.props.name as string);\n                return (e: any) => {\n                    ls(e);\n                    e.value = this.getValue();\n                    this.props.onInput && this.props.onInput(e);\n                }\n            }\n        }\n        return undefined;\n    }\n\n    public get label() {\n        return this.props.label;\n    }\n    public get isRequired() {\n        return this.props.required;\n    }\n    public get inputClass() {\n        return `form-control ${this.props.inputClass || null} ${this.isRequired ? 'required' : ''}`;\n    }\n    public get labelClass() {\n        return this.isRequired ? 'required' : '';\n    }\n    public get id() {\n        return this.props.id || this.props.name;\n    }\n    render(props?: any, state?: any) {\n        let attributes = { ...props, linkTo: null, label: null }\n        let placeholder = props.placeholder;\n\n        if (!placeholder && typeof props.label == 'string') {\n            placeholder = props.label;\n        }\n        return (\n            <div class=\"form-group\">\n                {this.label && <label for={this.id} class={this.labelClass}>{this.label}</label>}\n                <div class=\"input-group\">\n                    {this.prepend}\n                    <input {...attributes} ref={x => this.inp = x} onChange={this.getOnChange()} onInput={this.getOnInput()} value={this.getValue()} type={this.type} class={this.inputClass} name={props?.name} id={this.id} placeholder={placeholder} />\n                    {this.append}\n                </div>\n            </div>\n        );\n    }\n\n}","export function dset(obj: any, keys: string | any, val: any) {\n    keys.split && (keys = keys.split('.'));\n    var i = 0, l = keys.length, t = obj, x;\n    for (; i < l; ++i) {\n        x = t[keys[i]];\n        t = t[keys[i]] = (i === l - 1 ? val : (x != null ? x : (!!~keys[i + 1].indexOf('.') || !(+keys[i + 1] > -1)) ? {} : []));\n    }\n}\nexport function addBlankDefaultToItems(items: any[], defaultText?: string) {\n    return [{ name: defaultText, value: '' }].concat(items);\n}\n/**\n * todo(rc): needs to be better\n */\nexport function formatPhoneNumber(s: string) {\n    console.info('handle formatting better.')\n    var s2 = (\"\" + s).replace(/\\D/g, '');\n    var m = s2.match(/^(\\d{3})(\\d{3})(\\d{4})$/);\n    return (!m) ? null : \"(\" + m[1] + \") \" + m[2] + \"-\" + m[3];\n}\nimport dlv from 'dlv';\nexport function delve(object: object, key: string | Array<string | number>, defaultValue?: any) {\n    return dlv(object, key, defaultValue);\n}\nexport const dget = dlv;\n/**\n * Debounce a function call. \n * Useful for oninputs so its only called when user stops typing\n * @param delay \n * @param fn \n */\nexport function debounce(delay: number, fn: Function) {\n    let timerId: any;\n    return function (...args: any[]) {\n        if (timerId) {\n            clearTimeout(timerId);\n        }\n        timerId = setTimeout(() => {\n            fn(...args);\n            timerId = null;\n        }, delay);\n    };\n}\n/**\n * debounce with a default 500 ms(for now)\n * @param fn \n */\nexport function debouncex(fn: Function) {\n    return debounce(500, fn);\n}\n","import { Input, InputNameCheckProps } from \"./input\";\nimport { h } from 'preact';\nexport class Text<T> extends Input<InputNameCheckProps<T>> {\n    type = \"text\";\n    render(props?: any, state?: any) {\n        return super.render(props, state)\n    }\n}"],"names":["Input","prepend","append","inp","getValue","this","state","value","undefined","props","linkTo","dlv","name","defaultValue","getOnChange","ls","linkState","onChange","e","_this2","getOnInput","onInput","_this3","render","attributes","label","placeholder","class","h","for","id","labelClass","ref","x","_this4","type","inputClass","required","isRequired","Component","Text"],"mappings":"u1BAiEsBA,mKAGlBC,iBACAC,gBACAC,mDACAC,SAAA,WACI,OAAIC,KAAKC,MAAMC,WACCD,MAAMC,MAEKC,MAAvBH,KAAKI,MAAL,WACYA,MAAL,MAEPJ,KAAKI,MAAMC,OCxDZC,UDyDkBN,KAAKI,MAAMC,OAAOJ,MAAOD,KAAKI,MAAMG,UC1DWC,GD8DhER,KAAKF,SACOA,IAAII,cAIxBO,YAAA,sBAII,GAAIT,KAAKI,MAAMC,OAAQ,CACnB,IAAIK,EAAKC,UAAUX,KAAKI,MAAMC,OAAQL,KAAKI,MAAMG,MACjD,OAAIP,KAAKI,MAAMQ,kBACHC,GACJH,EAAGG,GACHC,EAAKV,MAAMQ,UAAYE,EAAKV,MAAMQ,SAASC,IAG5CH,EAIP,YAAYN,MAAMQ,YAG1BG,WAAA,sBACI,GAAIf,KAAKI,MAAMY,SACPhB,KAAKI,MAAMC,OAAQ,CACnB,IAAIK,EAAKC,UAAUX,KAAKI,MAAMC,OAAQL,KAAKI,MAAMG,MACjD,gBAAQM,GACJH,EAAGG,GACHA,EAAEX,MAAQe,EAAKlB,WACfkB,EAAKb,MAAMY,SAAWC,EAAKb,MAAMY,QAAQH,QAsBzDK,OAAA,SAAOd,EAAaH,cACZkB,OAAkBf,GAAOC,OAAQ,KAAMe,MAAO,OAC9CC,EAAcjB,EAAMiB,YAKxB,OAHKA,GAAqC,iBAAfjB,EAAMgB,QAC7BC,EAAcjB,EAAMgB,kBAGfE,MAAM,cACNtB,KAAKoB,OAASG,aAAOC,IAAKxB,KAAKyB,GAAIH,MAAOtB,KAAK0B,YAAa1B,KAAKoB,OAClEG,WAAKD,MAAM,eACNtB,KAAKJ,QACN2B,iBAAWJ,GAAYQ,IAAK,SAAAC,UAAKC,EAAK/B,IAAM8B,GAAGhB,SAAUZ,KAAKS,cAAeO,QAAShB,KAAKe,aAAcb,MAAOF,KAAKD,WAAY+B,KAAM9B,KAAK8B,KAAMR,MAAOtB,KAAK+B,WAAYxB,WAAMH,SAAAA,EAAOG,KAAMkB,GAAIzB,KAAKyB,GAAIJ,YAAaA,KACtNrB,KAAKH,mCA5BtB,WACI,YAAYO,MAAMgB,8BAEtB,WACI,YAAYhB,MAAM4B,iCAEtB,WACI,uBAAuBhC,KAAKI,MAAM2B,YAAc,WAAQ/B,KAAKiC,WAAa,WAAa,4BAE3F,WACI,YAAYA,WAAa,WAAa,mBAE1C,WACI,YAAY7B,MAAMqB,IAAMzB,KAAKI,MAAMG,oPArES2B,aE/DvCC,mKACTL,KAAO,mCACPZ,OAAA,SAAOd,EAAaH,GAChB,mBAAaiB,iBAAOd,EAAOH,OAHNN"}